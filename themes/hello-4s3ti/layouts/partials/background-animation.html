<!-- Animated Background Canvas -->
<canvas id="backgroundCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; opacity: 0.2;"></canvas>

<script>
// Animated Background - 3D Space Station
(function() {
    const canvas = document.getElementById('backgroundCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationId;
    
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // 3D Space Station using isometric projection
    const spaceStation = {
        x: 0.5,
        y: 0.5,
        scale: 0.35,
        size: 20
    };
    
    // Isometric projection function
    function project3D(x, y, z) {
        const isoX = (x - z) * 0.866; // cos(30°)
        const isoY = (x + z) * 0.5 - y; // sin(30°)
        return {x: isoX, y: isoY};
    }
    
    // Rotate point around Y axis
    function rotateY(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: point.x * cos + point.z * sin,
            y: point.y,
            z: -point.x * sin + point.z * cos
        };
    }
    
    // Rotate point around X axis
    function rotateX(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: point.x,
            y: point.y * cos - point.z * sin,
            z: point.y * sin + point.z * cos
        };
    }
    
    let time = 0;
    
    function drawSpaceStation3D(rotationX, rotationY) {
        const centerX = spaceStation.x * canvas.width;
        const centerY = spaceStation.y * canvas.height;
        const scale = spaceStation.scale * Math.min(canvas.width, canvas.height) / 100;
        const size = spaceStation.size * scale;
        
        // Helper function to transform and project a 3D point
        function transformPoint(v) {
            let rotated = {x: v.x * size, y: v.y * size, z: v.z * size};
            rotated = rotateY(rotated, rotationY);
            rotated = rotateX(rotated, rotationX);
            const proj = project3D(rotated.x, rotated.y, rotated.z);
            return {
                x: centerX + proj.x,
                y: centerY + proj.y,
                z: rotated.z
            };
        }
        
        // Helper function to draw a module (cylindrical/rectangular)
        function drawModule(center, length, radius, color, detailLines = true) {
            const moduleVertices = [
                {x: center.x - length/2, y: center.y - radius, z: center.z - radius},
                {x: center.x + length/2, y: center.y - radius, z: center.z - radius},
                {x: center.x + length/2, y: center.y + radius, z: center.z - radius},
                {x: center.x - length/2, y: center.y + radius, z: center.z - radius},
                {x: center.x - length/2, y: center.y - radius, z: center.z + radius},
                {x: center.x + length/2, y: center.y - radius, z: center.z + radius},
                {x: center.x + length/2, y: center.y + radius, z: center.z + radius},
                {x: center.x - length/2, y: center.y + radius, z: center.z + radius}
            ];
            
            const proj = moduleVertices.map(transformPoint);
            
            // Draw module faces
            const faces = [
                {indices: [0, 1, 2, 3], color: color, width: 2.5}, // front
                {indices: [4, 7, 6, 5], color: color.replace('0.65', '0.25'), width: 2}, // back
                {indices: [3, 2, 6, 7], color: color.replace('0.65', '0.55'), width: 2.5}, // top
                {indices: [0, 4, 5, 1], color: color.replace('0.65', '0.35'), width: 2}, // bottom
                {indices: [0, 3, 7, 4], color: color.replace('0.65', '0.45'), width: 2}, // left
                {indices: [1, 5, 6, 2], color: color.replace('0.65', '0.55'), width: 2.5}  // right
            ];
            
            faces.forEach(face => {
                ctx.strokeStyle = face.color;
                ctx.lineWidth = face.width;
                ctx.beginPath();
                ctx.moveTo(proj[face.indices[0]].x, proj[face.indices[0]].y);
                for (let i = 1; i < face.indices.length; i++) {
                    ctx.lineTo(proj[face.indices[i]].x, proj[face.indices[i]].y);
                }
                ctx.closePath();
                ctx.stroke();
            });
            
            // Draw detail lines on module
            if (detailLines) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.lineWidth = 0.8;
                const detailLines3D = [
                    [{x: center.x - length/4, y: center.y - radius, z: center.z - radius}, 
                     {x: center.x - length/4, y: center.y + radius, z: center.z - radius}],
                    [{x: center.x + length/4, y: center.y - radius, z: center.z - radius}, 
                     {x: center.x + length/4, y: center.y + radius, z: center.z - radius}],
                    [{x: center.x - length/2, y: center.y, z: center.z - radius}, 
                     {x: center.x + length/2, y: center.y, z: center.z - radius}]
                ];
                detailLines3D.forEach(line => {
                    const p1 = transformPoint(line[0]);
                    const p2 = transformPoint(line[1]);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });
            }
        }
        
        // Draw central core module (largest)
        drawModule({x: 0, y: 0, z: 0}, 1.2, 0.5, 'rgba(0, 255, 0, 0.65)');
        
        // Draw side modules (laboratory/living modules)
        drawModule({x: -1.8, y: 0, z: 0}, 0.8, 0.4, 'rgba(0, 255, 0, 0.6)');
        drawModule({x: 1.8, y: 0, z: 0}, 0.8, 0.4, 'rgba(0, 255, 0, 0.6)');
        
        // Draw connecting truss/trusses between modules
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
        ctx.lineWidth = 1.5;
        const trusses = [
            [{x: -0.6, y: 0, z: 0}, {x: -1.4, y: 0, z: 0}],
            [{x: 0.6, y: 0, z: 0}, {x: 1.4, y: 0, z: 0}]
        ];
        trusses.forEach(truss => {
            const p1 = transformPoint(truss[0]);
            const p2 = transformPoint(truss[1]);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        });
        
        // Draw large solar panel arrays (left and right, extending outward)
        const solarPanels = [
            {base: {x: -2.5, y: 0, z: 0}, normal: {x: -1, y: 0, z: 0}, width: size * 1.2, height: size * 0.8, segments: 3},
            {base: {x: 2.5, y: 0, z: 0}, normal: {x: 1, y: 0, z: 0}, width: size * 1.2, height: size * 0.8, segments: 3}
        ];
        
        solarPanels.forEach(panel => {
            const panelCorners = [
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y - panel.height * 0.5, z: panel.base.z - panel.width * 0.5},
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y - panel.height * 0.5, z: panel.base.z + panel.width * 0.5},
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y + panel.height * 0.5, z: panel.base.z + panel.width * 0.5},
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y + panel.height * 0.5, z: panel.base.z - panel.width * 0.5}
            ];
            
            const panelProj = panelCorners.map(transformPoint);
            
            // Draw panel frame
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelProj[0].x, panelProj[0].y);
            for (let i = 1; i < panelProj.length; i++) {
                ctx.lineTo(panelProj[i].x, panelProj[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Draw detailed grid pattern on solar panels
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.25)';
            ctx.lineWidth = 0.6;
            const gridLines = 6;
            for (let i = 1; i < gridLines; i++) {
                // Vertical grid lines
                const v1 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y - panel.height * 0.5 + (panel.height / gridLines) * i,
                    z: panel.base.z - panel.width * 0.5
                };
                const v2 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y - panel.height * 0.5 + (panel.height / gridLines) * i,
                    z: panel.base.z + panel.width * 0.5
                };
                const pv1 = transformPoint(v1);
                const pv2 = transformPoint(v2);
                ctx.beginPath();
                ctx.moveTo(pv1.x, pv1.y);
                ctx.lineTo(pv2.x, pv2.y);
                ctx.stroke();
                
                // Horizontal grid lines
                const h1 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y - panel.height * 0.5,
                    z: panel.base.z - panel.width * 0.5 + (panel.width / gridLines) * i
                };
                const h2 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y + panel.height * 0.5,
                    z: panel.base.z - panel.width * 0.5 + (panel.width / gridLines) * i
                };
                const ph1 = transformPoint(h1);
                const ph2 = transformPoint(h2);
                ctx.beginPath();
                ctx.moveTo(ph1.x, ph1.y);
                ctx.lineTo(ph2.x, ph2.y);
                ctx.stroke();
            }
        });
        
        // Draw docking ports
        const dockingPorts = [
            {pos: {x: 0, y: 0, z: 0.6}, size: 0.3},
            {pos: {x: 0, y: 0, z: -0.6}, size: 0.3},
            {pos: {x: -1.8, y: 0, z: 0.4}, size: 0.25},
            {pos: {x: 1.8, y: 0, z: 0.4}, size: 0.25}
        ];
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 1.5;
        dockingPorts.forEach(port => {
            const center = transformPoint(port.pos);
            ctx.beginPath();
            ctx.arc(center.x, center.y, port.size * size * 0.8, 0, Math.PI * 2);
            ctx.stroke();
            // Inner circle
            ctx.beginPath();
            ctx.arc(center.x, center.y, port.size * size * 0.5, 0, Math.PI * 2);
            ctx.stroke();
        });
        
        // Draw communication antennas
        const antennas = [
            {base: {x: 0, y: 0.5, z: 0}, dir: {x: 0, y: 1.5, z: 0}, length: size * 1.2, width: 1.8},
            {base: {x: 0, y: -0.5, z: 0}, dir: {x: 0, y: -1.5, z: 0}, length: size * 1.2, width: 1.8},
            {base: {x: -1.8, y: 0.4, z: 0}, dir: {x: -1.2, y: 0.8, z: 0}, length: size * 1.0, width: 1.2},
            {base: {x: 1.8, y: 0.4, z: 0}, dir: {x: 1.2, y: 0.8, z: 0}, length: size * 1.0, width: 1.2}
        ];
        
        antennas.forEach(antenna => {
            const start = transformPoint(antenna.base);
            let end3D = {
                x: (antenna.base.x + antenna.dir.x) * antenna.length,
                y: (antenna.base.y + antenna.dir.y) * antenna.length,
                z: (antenna.base.z + antenna.dir.z) * antenna.length
            };
            end3D = rotateY(end3D, rotationY);
            end3D = rotateX(end3D, rotationX);
            const endProj = project3D(end3D.x, end3D.y, end3D.z);
            const endX = centerX + endProj.x;
            const endY = centerY + endProj.y;
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
            ctx.lineWidth = antenna.width;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Antenna tip
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(endX, endY, 4, 0, Math.PI * 2);
            ctx.stroke();
        });
        
        // Draw small sensors and instruments
        const sensors = [
            {pos: {x: 0.4, y: 0.5, z: 0.6}, size: 0.12},
            {pos: {x: -0.4, y: 0.5, z: 0.6}, size: 0.12},
            {pos: {x: 0.4, y: -0.5, z: 0.6}, size: 0.12},
            {pos: {x: -0.4, y: -0.5, z: 0.6}, size: 0.12},
            {pos: {x: -1.8, y: 0.3, z: 0.4}, size: 0.1},
            {pos: {x: 1.8, y: 0.3, z: 0.4}, size: 0.1}
        ];
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 1;
        sensors.forEach(sensor => {
            const center = transformPoint(sensor.pos);
            ctx.beginPath();
            ctx.arc(center.x, center.y, sensor.size * size * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Cross inside
            ctx.beginPath();
            ctx.moveTo(center.x - sensor.size * size * 0.4, center.y);
            ctx.lineTo(center.x + sensor.size * size * 0.4, center.y);
            ctx.moveTo(center.x, center.y - sensor.size * size * 0.4);
            ctx.lineTo(center.x, center.y + sensor.size * size * 0.4);
            ctx.stroke();
        });
        
        // Draw radiator panels (on modules)
        const radiators = [
            {base: {x: -0.6, y: 0.5, z: 0}, normal: {x: 0, y: 1, z: 0}, width: size * 0.4, height: size * 0.3},
            {base: {x: 0.6, y: 0.5, z: 0}, normal: {x: 0, y: 1, z: 0}, width: size * 0.4, height: size * 0.3},
            {base: {x: -0.6, y: -0.5, z: 0}, normal: {x: 0, y: -1, z: 0}, width: size * 0.4, height: size * 0.3},
            {base: {x: 0.6, y: -0.5, z: 0}, normal: {x: 0, y: -1, z: 0}, width: size * 0.4, height: size * 0.3}
        ];
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.lineWidth = 1;
        radiators.forEach(rad => {
            const radCorners = [
                {x: rad.base.x - rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z - rad.width * 0.3},
                {x: rad.base.x + rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z - rad.width * 0.3},
                {x: rad.base.x + rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z + rad.width * 0.3},
                {x: rad.base.x - rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z + rad.width * 0.3}
            ];
            const radProj = radCorners.map(transformPoint);
            ctx.beginPath();
            ctx.moveTo(radProj[0].x, radProj[0].y);
            for (let i = 1; i < radProj.length; i++) {
                ctx.lineTo(radProj[i].x, radProj[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        time += 0.01;
        
        // 3D rotation angles (slower rotation)
        const rotationX = time * 0.3;
        const rotationY = time * 0.5;
        
        // Draw 3D space station
        drawSpaceStation3D(rotationX, rotationY);
        
        animationId = requestAnimationFrame(animate);
    }
    
    // Start animation after a short delay to ensure canvas is ready
    setTimeout(() => {
        animate();
    }, 100);
})();
</script>

