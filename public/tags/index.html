<!DOCTYPE html>
<html lang="en" data-theme="dark">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="AetherNeo Team">
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/tags/" />


    <title>
        
            Tags :: AetherNeo LLC 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css" crossorigin="anonymous" referrerpolicy="no-referrer">



<link rel="stylesheet" href="/main.0dfb685a37b661191196f136e0d0946752a071555e7d9747c22bc7952e008436.css">





    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Tags">
  <meta itemprop="description" content="AetherNeo LLC provides enterprise-grade network security and AI-driven automation solutions.">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Tags">
  <meta name="twitter:description" content="AetherNeo LLC provides enterprise-grade network security and AI-driven automation solutions.">









<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/index.xml" title="AetherNeo LLC" />







    </head>

    
        <body>
    
    
        
<canvas id="backgroundCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; opacity: 0.2;"></canvas>

<script>

(function() {
    const canvas = document.getElementById('backgroundCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationId;
    
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    
    const spaceStation = {
        x: 0.5,
        y: 0.5,
        scale: 0.35,
        size: 20
    };
    
    
    function project3D(x, y, z) {
        const isoX = (x - z) * 0.866; 
        const isoY = (x + z) * 0.5 - y; 
        return {x: isoX, y: isoY};
    }
    
    
    function rotateY(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: point.x * cos + point.z * sin,
            y: point.y,
            z: -point.x * sin + point.z * cos
        };
    }
    
    
    function rotateX(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: point.x,
            y: point.y * cos - point.z * sin,
            z: point.y * sin + point.z * cos
        };
    }
    
    let time = 0;
    
    function drawSpaceStation3D(rotationX, rotationY) {
        const centerX = spaceStation.x * canvas.width;
        const centerY = spaceStation.y * canvas.height;
        const scale = spaceStation.scale * Math.min(canvas.width, canvas.height) / 100;
        const size = spaceStation.size * scale;
        
        
        function transformPoint(v) {
            let rotated = {x: v.x * size, y: v.y * size, z: v.z * size};
            rotated = rotateY(rotated, rotationY);
            rotated = rotateX(rotated, rotationX);
            const proj = project3D(rotated.x, rotated.y, rotated.z);
            return {
                x: centerX + proj.x,
                y: centerY + proj.y,
                z: rotated.z
            };
        }
        
        
        function drawModule(center, length, radius, color, detailLines = true) {
            const moduleVertices = [
                {x: center.x - length/2, y: center.y - radius, z: center.z - radius},
                {x: center.x + length/2, y: center.y - radius, z: center.z - radius},
                {x: center.x + length/2, y: center.y + radius, z: center.z - radius},
                {x: center.x - length/2, y: center.y + radius, z: center.z - radius},
                {x: center.x - length/2, y: center.y - radius, z: center.z + radius},
                {x: center.x + length/2, y: center.y - radius, z: center.z + radius},
                {x: center.x + length/2, y: center.y + radius, z: center.z + radius},
                {x: center.x - length/2, y: center.y + radius, z: center.z + radius}
            ];
            
            const proj = moduleVertices.map(transformPoint);
            
            
            const faces = [
                {indices: [0, 1, 2, 3], color: color, width: 2.5}, 
                {indices: [4, 7, 6, 5], color: color.replace('0.65', '0.25'), width: 2}, 
                {indices: [3, 2, 6, 7], color: color.replace('0.65', '0.55'), width: 2.5}, 
                {indices: [0, 4, 5, 1], color: color.replace('0.65', '0.35'), width: 2}, 
                {indices: [0, 3, 7, 4], color: color.replace('0.65', '0.45'), width: 2}, 
                {indices: [1, 5, 6, 2], color: color.replace('0.65', '0.55'), width: 2.5}  
            ];
            
            faces.forEach(face => {
                ctx.strokeStyle = face.color;
                ctx.lineWidth = face.width;
                ctx.beginPath();
                ctx.moveTo(proj[face.indices[0]].x, proj[face.indices[0]].y);
                for (let i = 1; i < face.indices.length; i++) {
                    ctx.lineTo(proj[face.indices[i]].x, proj[face.indices[i]].y);
                }
                ctx.closePath();
                ctx.stroke();
            });
            
            
            if (detailLines) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.lineWidth = 0.8;
                const detailLines3D = [
                    [{x: center.x - length/4, y: center.y - radius, z: center.z - radius}, 
                     {x: center.x - length/4, y: center.y + radius, z: center.z - radius}],
                    [{x: center.x + length/4, y: center.y - radius, z: center.z - radius}, 
                     {x: center.x + length/4, y: center.y + radius, z: center.z - radius}],
                    [{x: center.x - length/2, y: center.y, z: center.z - radius}, 
                     {x: center.x + length/2, y: center.y, z: center.z - radius}]
                ];
                detailLines3D.forEach(line => {
                    const p1 = transformPoint(line[0]);
                    const p2 = transformPoint(line[1]);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });
            }
        }
        
        
        drawModule({x: 0, y: 0, z: 0}, 1.2, 0.5, 'rgba(0, 255, 0, 0.65)');
        
        
        drawModule({x: -1.8, y: 0, z: 0}, 0.8, 0.4, 'rgba(0, 255, 0, 0.6)');
        drawModule({x: 1.8, y: 0, z: 0}, 0.8, 0.4, 'rgba(0, 255, 0, 0.6)');
        
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
        ctx.lineWidth = 1.5;
        const trusses = [
            [{x: -0.6, y: 0, z: 0}, {x: -1.4, y: 0, z: 0}],
            [{x: 0.6, y: 0, z: 0}, {x: 1.4, y: 0, z: 0}]
        ];
        trusses.forEach(truss => {
            const p1 = transformPoint(truss[0]);
            const p2 = transformPoint(truss[1]);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        });
        
        
        const solarPanels = [
            {base: {x: -2.5, y: 0, z: 0}, normal: {x: -1, y: 0, z: 0}, width: size * 1.2, height: size * 0.8, segments: 3},
            {base: {x: 2.5, y: 0, z: 0}, normal: {x: 1, y: 0, z: 0}, width: size * 1.2, height: size * 0.8, segments: 3}
        ];
        
        solarPanels.forEach(panel => {
            const panelCorners = [
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y - panel.height * 0.5, z: panel.base.z - panel.width * 0.5},
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y - panel.height * 0.5, z: panel.base.z + panel.width * 0.5},
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y + panel.height * 0.5, z: panel.base.z + panel.width * 0.5},
                {x: panel.base.x + panel.normal.x * size * 0.2, y: panel.base.y + panel.height * 0.5, z: panel.base.z - panel.width * 0.5}
            ];
            
            const panelProj = panelCorners.map(transformPoint);
            
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelProj[0].x, panelProj[0].y);
            for (let i = 1; i < panelProj.length; i++) {
                ctx.lineTo(panelProj[i].x, panelProj[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.25)';
            ctx.lineWidth = 0.6;
            const gridLines = 6;
            for (let i = 1; i < gridLines; i++) {
                
                const v1 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y - panel.height * 0.5 + (panel.height / gridLines) * i,
                    z: panel.base.z - panel.width * 0.5
                };
                const v2 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y - panel.height * 0.5 + (panel.height / gridLines) * i,
                    z: panel.base.z + panel.width * 0.5
                };
                const pv1 = transformPoint(v1);
                const pv2 = transformPoint(v2);
                ctx.beginPath();
                ctx.moveTo(pv1.x, pv1.y);
                ctx.lineTo(pv2.x, pv2.y);
                ctx.stroke();
                
                
                const h1 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y - panel.height * 0.5,
                    z: panel.base.z - panel.width * 0.5 + (panel.width / gridLines) * i
                };
                const h2 = {
                    x: panel.base.x + panel.normal.x * size * 0.2,
                    y: panel.base.y + panel.height * 0.5,
                    z: panel.base.z - panel.width * 0.5 + (panel.width / gridLines) * i
                };
                const ph1 = transformPoint(h1);
                const ph2 = transformPoint(h2);
                ctx.beginPath();
                ctx.moveTo(ph1.x, ph1.y);
                ctx.lineTo(ph2.x, ph2.y);
                ctx.stroke();
            }
        });
        
        
        const dockingPorts = [
            {pos: {x: 0, y: 0, z: 0.6}, size: 0.3},
            {pos: {x: 0, y: 0, z: -0.6}, size: 0.3},
            {pos: {x: -1.8, y: 0, z: 0.4}, size: 0.25},
            {pos: {x: 1.8, y: 0, z: 0.4}, size: 0.25}
        ];
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 1.5;
        dockingPorts.forEach(port => {
            const center = transformPoint(port.pos);
            ctx.beginPath();
            ctx.arc(center.x, center.y, port.size * size * 0.8, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(center.x, center.y, port.size * size * 0.5, 0, Math.PI * 2);
            ctx.stroke();
        });
        
        
        const antennas = [
            {base: {x: 0, y: 0.5, z: 0}, dir: {x: 0, y: 1.5, z: 0}, length: size * 1.2, width: 1.8},
            {base: {x: 0, y: -0.5, z: 0}, dir: {x: 0, y: -1.5, z: 0}, length: size * 1.2, width: 1.8},
            {base: {x: -1.8, y: 0.4, z: 0}, dir: {x: -1.2, y: 0.8, z: 0}, length: size * 1.0, width: 1.2},
            {base: {x: 1.8, y: 0.4, z: 0}, dir: {x: 1.2, y: 0.8, z: 0}, length: size * 1.0, width: 1.2}
        ];
        
        antennas.forEach(antenna => {
            const start = transformPoint(antenna.base);
            let end3D = {
                x: (antenna.base.x + antenna.dir.x) * antenna.length,
                y: (antenna.base.y + antenna.dir.y) * antenna.length,
                z: (antenna.base.z + antenna.dir.z) * antenna.length
            };
            end3D = rotateY(end3D, rotationY);
            end3D = rotateX(end3D, rotationX);
            const endProj = project3D(end3D.x, end3D.y, end3D.z);
            const endX = centerX + endProj.x;
            const endY = centerY + endProj.y;
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
            ctx.lineWidth = antenna.width;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(endX, endY, 4, 0, Math.PI * 2);
            ctx.stroke();
        });
        
        
        const sensors = [
            {pos: {x: 0.4, y: 0.5, z: 0.6}, size: 0.12},
            {pos: {x: -0.4, y: 0.5, z: 0.6}, size: 0.12},
            {pos: {x: 0.4, y: -0.5, z: 0.6}, size: 0.12},
            {pos: {x: -0.4, y: -0.5, z: 0.6}, size: 0.12},
            {pos: {x: -1.8, y: 0.3, z: 0.4}, size: 0.1},
            {pos: {x: 1.8, y: 0.3, z: 0.4}, size: 0.1}
        ];
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 1;
        sensors.forEach(sensor => {
            const center = transformPoint(sensor.pos);
            ctx.beginPath();
            ctx.arc(center.x, center.y, sensor.size * size * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(center.x - sensor.size * size * 0.4, center.y);
            ctx.lineTo(center.x + sensor.size * size * 0.4, center.y);
            ctx.moveTo(center.x, center.y - sensor.size * size * 0.4);
            ctx.lineTo(center.x, center.y + sensor.size * size * 0.4);
            ctx.stroke();
        });
        
        
        const radiators = [
            {base: {x: -0.6, y: 0.5, z: 0}, normal: {x: 0, y: 1, z: 0}, width: size * 0.4, height: size * 0.3},
            {base: {x: 0.6, y: 0.5, z: 0}, normal: {x: 0, y: 1, z: 0}, width: size * 0.4, height: size * 0.3},
            {base: {x: -0.6, y: -0.5, z: 0}, normal: {x: 0, y: -1, z: 0}, width: size * 0.4, height: size * 0.3},
            {base: {x: 0.6, y: -0.5, z: 0}, normal: {x: 0, y: -1, z: 0}, width: size * 0.4, height: size * 0.3}
        ];
        
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.lineWidth = 1;
        radiators.forEach(rad => {
            const radCorners = [
                {x: rad.base.x - rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z - rad.width * 0.3},
                {x: rad.base.x + rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z - rad.width * 0.3},
                {x: rad.base.x + rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z + rad.width * 0.3},
                {x: rad.base.x - rad.width * 0.5, y: rad.base.y + rad.normal.y * rad.height * 0.5, z: rad.base.z + rad.width * 0.3}
            ];
            const radProj = radCorners.map(transformPoint);
            ctx.beginPath();
            ctx.moveTo(radProj[0].x, radProj[0].y);
            for (let i = 1; i < radProj.length; i++) {
                ctx.lineTo(radProj[i].x, radProj[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        time += 0.01;
        
        
        const rotationX = time * 0.3;
        const rotationY = time * 0.5;
        
        
        drawSpaceStation3D(rotationX, rotationY);
        
        animationId = requestAnimationFrame(animate);
    }
    
    
    setTimeout(() => {
        animate();
    }, 100);
})();
</script>


    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">AetherNeo</span>
            <span class="logo__cursor" style=
                  "
                   background-color:#00ff00;
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner">
            
            <div class="submenu">
                <li class="dropdown">
                    <a href="/services">
                        Services
                    </a>
                </li>
            </div>
            
        
            
            <div class="submenu">
                <li class="dropdown">
                    <a href="/capabilities">
                        Capabilities
                    </a>
                </li>
            </div>
            
        
            
            <div class="submenu">
                <li class="dropdown">
                    <a href="/case-studies">
                        Case Studies
                    </a>
                </li>
            </div>
            
        
            
            <div class="submenu">
                <li class="dropdown">
                    <a href="/about">
                        About
                    </a>
                </li>
            </div>
            
        
            
            <div class="submenu">
                <li class="dropdown">
                    <a href="/contact">
                        Contact
                    </a>
                </li>
            </div>
            
        

    
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    
    
    <main class="posts">
        <h1>Tags</h1>

        

        
    <div class="pagination">
    <div class="pagination__buttons">
        
        
    </div>
</div>

    </main>

            </div>

            
                <footer class="footer">
    
        <div class="footer__inner footer__legal-links">
            <div class="footer__content">
                <span><a href="/privacy">Privacy Policy</a></span><span><a href="/terms">Terms of Service</a></span>
            </div>
        </div>
    
    
        <div class="footer__inner">
            <div class="footer__content">
            
            
                <span>Â© 2025 Copyright AetherNeo LLC</span><span>Cloud Productivity & Privacy Suite</span> 
            
            </div>
        </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.fda5930ad297995dde9f60d7d3241312e6242fcdddbf48b483bca32e377cec129736b80bbb67d35f38e3b8d6d0fb6990eb092fba3079c6d3183492c991e13221.js" integrity="sha512-/aWTCtKXmV3en2DX0yQTEuYkL83dv0i0g7yjLjd87BKXNrgLu2fTXzjjuNbQ&#43;2mQ6wkvujB5xtMYNJLJkeEyIQ=="></script>



    </body>
</html>
